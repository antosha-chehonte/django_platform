# Парсинг файлов сертификатов (.cer, .pfx)

В приложение `access_management` добавлена возможность автоматического парсинга файлов сертификатов электронной подписи для автоматического заполнения полей модели `DigitalSignature`.

## Функциональность

### Поддерживаемые форматы
- **.cer** - сертификаты в формате DER (бинарный) или PEM (текстовый)
- **.pfx** - сертификаты в формате PKCS12 (требуется пароль)

### Извлекаемые данные
При парсинге сертификата автоматически извлекаются следующие данные:

1. **Серийный номер сертификата** (`certificate_serial`)
   - Извлекается из поля `serial_number` сертификата
   - Формат: шестнадцатеричное число

2. **Отпечаток сертификата** (`certificate_alias`)
   - SHA-1 fingerprint сертификата
   - Формат: hex-строка без пробелов (например: "A1B2C3D4E5F6...")

3. **Дата окончания действия** (`expiry_date`)
   - Извлекается из поля `not_valid_after`
   - Используется для автоматического определения статуса

4. **Дата начала действия** (`valid_from`)
   - Извлекается из поля `not_valid_before`
   - Сохраняется в примечаниях

5. **Информация о субъекте** (`subject_name`)
   - Извлекается из поля `CN` (Common Name) или из полей `SN` (Surname) + `GN` (Given Name)
   - Может использоваться для подсказки при выборе сотрудника

6. **Издатель сертификата** (`issuer_name`)
   - Извлекается из поля `CN` издателя
   - Сохраняется в примечаниях

## Использование

### Автоматическое заполнение при создании записи

1. Откройте форму создания цифровой подписи
2. Загрузите файл сертификата (.cer или .pfx)
3. Убедитесь, что включен чекбокс "Автоматически заполнить данные из файла сертификата" (включен по умолчанию)
4. После отправки формы поля будут автоматически заполнены:
   - `certificate_serial` - серийный номер
   - `certificate_alias` - отпечаток
   - `expiry_date` - дата окончания
   - `status` - автоматически определяется по сроку действия
   - `notes` - информация о субъекте и издателе (если поле пустое)

### Автоматическое определение статуса

Статус сертификата устанавливается автоматически:
- **Активен** - если срок действия еще не истек
- **Требует актуализации** - если срок действия истек

### AJAX endpoint для парсинга

Для реализации автоматического заполнения полей на клиенте без отправки формы доступен AJAX endpoint:

**URL:** `/access/signatures/parse-certificate/`

**Метод:** POST

**Параметры:**
- `certificate_file` - файл сертификата

**Ответ (успех):**
```json
{
    "success": true,
    "data": {
        "certificate_serial": "00BE7798D6824402891B4A5FCCDE076788",
        "certificate_alias": "A1 B2 C3 D4 E5 F6...",
        "expiry_date": "2024-11-01",
        "status": "active",
        "subject_name": "Иванов Иван Иванович",
        "issuer_name": "Удостоверяющий центр",
        "valid_from": "2023-08-09"
    }
}
```

**Ответ (ошибка):**
```json
{
    "success": false,
    "error": "Описание ошибки"
}
```

## Технические детали

### Зависимости

Требуется библиотека `cryptography` версии >= 42.0.0:
```bash
pip install cryptography>=42.0.0
```

### Структура кода

1. **Утилита парсинга:** `apps/access_management/utils/certificate_parser.py`
   - `parse_certificate_file()` - основная функция парсинга
   - `parse_certificate_from_django_file()` - удобная обертка для Django FileField
   - `get_certificate_thumbprint()` - получение только отпечатка

2. **Форма:** `apps/access_management/forms.py`
   - Класс `DigitalSignatureForm` с методом `clean()` для автоматического заполнения

3. **Представление:** `apps/access_management/views.py`
   - `CertificateParseAjaxView` - AJAX endpoint для парсинга

### Обработка ошибок

Если парсинг сертификата не удался:
- Форма не блокирует сохранение
- Показывается сообщение об ошибке
- Пользователь может заполнить поля вручную

### Примеры использования в коде

```python
from apps.access_management.utils.certificate_parser import parse_certificate_file

# Парсинг из байтов
with open('certificate.cer', 'rb') as f:
    content = f.read()
    cert_data = parse_certificate_file(content, 'certificate.cer')

print(cert_data['certificate_serial'])
print(cert_data['expiry_date'])
```

```python
from apps.access_management.utils.certificate_parser import parse_certificate_from_django_file

# Парсинг из Django FileField
cert_data = parse_certificate_from_django_file(request.FILES['certificate_file'])
```

## Ограничения

1. **Файлы .pfx** требуют пароля для расшифровки. Текущая реализация не поддерживает ввод пароля через интерфейс. Для работы с .pfx файлами необходимо либо:
   - Использовать файлы без пароля
   - Добавить функционал ввода пароля в форму

2. **Размер файла** ограничен валидатором модели (1 МБ)

3. **Формат данных** - поддерживаются только стандартные X.509 сертификаты

## Расширение функциональности

Для добавления поддержки других форматов или дополнительных полей:

1. Расширьте функцию `_parse_*` в `certificate_parser.py`
2. Добавьте извлечение дополнительных полей в `_extract_certificate_data()`
3. Обновите форму для отображения новых полей

## Тестирование

Для тестирования парсинга:

1. Создайте тестовый сертификат
2. Загрузите его через форму создания цифровой подписи
3. Проверьте автоматическое заполнение полей
4. Убедитесь, что статус определяется корректно

