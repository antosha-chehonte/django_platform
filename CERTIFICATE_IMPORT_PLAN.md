# План доработки приложения access_management для импорта сертификатов

## Анализ HTML-файла

### Структура данных в файле 01.html

После анализа сохраненной HTML-страницы выявлена следующая структура:

1. **Каждый сертификат** представлен блоком: `<div class="cert-item active">`
2. **Номер сертификата** находится в: 
   - Путь: `div.cert-item-content.contWidth1 > div > div` (после символа "№")
   - Формат: строка с пробелом (например: "00BE7798D6824402891B4A5FCCDE07 6788")
3. **ФИО владельца** находится в:
   - Путь: `div.cert-item-content.contWidth2 > div.owner-name > b`
   - Формат: "Фамилия Имя Отчество"
4. **Конец срока действия** находится в:
   - Путь: `div.cert-item-content-right > table > tr > td` (вторая строка таблицы)
   - Формат: "DD.MM.YYYY HH:MM" (нужна только дата, время можно игнорировать)

### Примеры извлеченных данных:

- **Пример 1:**
  - Номер: `00BE7798D6824402891B4A5FCCDE07 6788`
  - ФИО: `Цыганенко Любовь Ивановна`
  - Срок действия: `01.11.2024`

- **Пример 2:**
  - Номер: `00EAD730D6231C76F5BC9142CC3E3C A84A`
  - ФИО: `Фадеева Инна Васильевна`
  - Срок действия: `31.10.2024`

## План реализации

### Этап 1: Парсинг HTML-файла

#### 1.1. Создать утилиту парсинга
**Файл:** `apps/access_management/utils/certificate_parser.py`

**Функционал:**
- Использовать библиотеку `BeautifulSoup4` для парсинга HTML
- Функция `parse_certificate_html(html_file)` для извлечения списка сертификатов
- Возвращать список словарей с данными:
  ```python
  {
      'certificate_number': str,  # без пробелов или с пробелами?
      'owner_name': str,  # "Фамилия Имя Отчество"
      'expiry_date': datetime.date,  # из строки "DD.MM.YYYY"
  }
  ```

**Вопросы:**
1. Не нужно сохранять пробелы в номере сертификата
2. В одном файле может быть несколько сертификатов у одного сотрудника
3. Некорректные или неполные данные в HTML нужно пропускать, сообщить об этом на странице результатов импорта.

### Этап 2: Сопоставление с существующими данными

#### 2.1. Сопоставление по ФИО
**Файл:** `apps/access_management/utils/certificate_matcher.py`

**Функционал:**
- Функция `match_employee_by_name(full_name: str)` для поиска сотрудника по ФИО
- Обработка вариантов написания (регистр, лишние пробелы)
- Разбор ФИО на составляющие (фамилия, имя, отчество)

**Вопросы:**
4. Пропускать запись, когда сотрудник не найден по ФИО, сообщить об этом на странице результатов импорта.
5. Запрашивать уточнение у пользователя, когда найдено несколько сотрудников с одинаковым ФИО

#### 2.2. Проверка существующих сертификатов
**Функционал:**
- Проверка, существует ли уже сертификат с таким номером, при наличии - пропустить

**Вопросы:**
6. Дубликаты по номеру сертификата пропускать.
7. Определить тип сертификата (`certificate_type`):
   - В HTML есть текст "Сертификат должностного лица" - это соответствует типу "Физического лица"

### Этап 3: Форма и представление для импорта

#### 3.1. Создать форму импорта
**Файл:** `apps/access_management/forms.py` (добавить класс)

**Класс:** `CertificateImportForm`

**Поля:**
- `html_file`: FileField (загрузка HTML-файла)
- `certificate_type`: ChoiceField (выбор типа сертификата из справочника)
- `update_existing`: BooleanField (обновлять ли существующие записи?)
- `create_if_employee_not_found`: BooleanField (создавать ли записи, если сотрудник не найден?)
- `skip_duplicates`: BooleanField (пропускать ли дубликаты?)

**Вопросы:**
8. Нужна ли возможность массового выбора действий для каждого импортируемого сертификата? Я не понял вопрос, задай подробнее, с примером.
9. Нужна предварительная обработка - показ списка найденных сертификатов перед импортом.

#### 3.2. Создать представление импорта
**Файл:** `apps/access_management/views.py` (добавить классы)

**Классы:**
- `CertificateImportView` (GET и POST методы)
- `CertificateImportPreviewView` (опционально, для предварительного просмотра)

**Функционал:**
- Загрузка файла
- Парсинг и валидация данных
- Сопоставление с существующими сотрудниками
- Показ результатов (сколько найдено, сколько сопоставлено, ошибки)
- Массовое создание/обновление записей `DigitalSignature`

**Вопросы:**
10. Не нужна возможность скачивания отчета об импорте
11. Какие действия должны быть доступны при ошибках:
    - Показывать список ошибок.
    - Позволить импортировать только успешные записи.

### Этап 4: URL и шаблоны

#### 4.1. Добавить URL
**Файл:** `apps/access_management/urls.py`

**Добавить:**
```python
path('signatures/import/', views.CertificateImportView.as_view(), name='digital_signature_import'),
```

#### 4.2. Создать шаблоны
**Файлы:**
- `templates/access_management/certificate_import.html` (форма импорта)
- `templates/access_management/certificate_import_result.html` (результаты импорта)
- `templates/access_management/certificate_import_preview.html` (опционально, предпросмотр)

**Вопросы:**
12. Стиль интерфейса согласовать с существующими шаблонами
13. Не нужна пагинация для результатов импорта, если их много

### Этап 5: Обработка данных и валидация

#### 5.1. Валидация данных
**Функционал:**
- Проверка формата номера сертификата
- Проверка формата даты
- Проверка корректности ФИО (минимум фамилия и имя)
- Валидация размера файла не нужна

**Вопросы:**
14. Валидация размера файла не нужна
15. Не нужна проверка формата HTML (принимать любой HTML)

#### 5.2. Массовое создание/обновление
**Функционал:**
- Использовать `bulk_create` и `bulk_update` для производительности
- Транзакции для целостности данных

**Вопросы:**
16. Не нужно логирование импорта
17. Не нужны уведомления об импорте

### Этап 6: Обработка ошибок и исключений

#### 6.1. Типы ошибок
- Файл не найден или поврежден
- Некорректный формат данных
- Сотрудник не найден
- Ошибки при сохранении в БД

#### 6.2. Отчетность не нужна.

### Этап 7: Тестирование не требуется

## Зависимости

### Необходимые библиотеки
- `beautifulsoup4` - для парсинга HTML
- `lxml` или `html.parser` - парсер для BeautifulSoup

**Вопрос:**
19. Я не могу выбрать предпочтительный парсер для BeautifulSoup, реши сам.

## Последовательность разработки

1. **Шаг 1:** Установить зависимости (`beautifulsoup4`)
2. **Шаг 2:** Создать утилиту парсинга HTML (Этап 1)
3. **Шаг 3:** Создать утилиту сопоставления сотрудников (Этап 2)
4. **Шаг 4:** Создать форму импорта (Этап 3.1)
5. **Шаг 5:** Создать представление импорта (Этап 3.2)
6. **Шаг 6:** Добавить URL и шаблоны (Этап 4)
7. **Шаг 7:** Добавить ссылку на импорт в интерфейс списка сертификатов
8. **Шаг 8:** Тестирование не нужно
9. **Шаг 9:** Обработка ошибок и улучшение UX (Этап 5, 6)

## Связь с существующими моделями

### Модель DigitalSignature
Импорт будет создавать/обновлять записи модели `DigitalSignature` со следующими полями:
- `employee` - находится по ФИО
- `certificate_type` - определяется пользователем или автоматически
- `certificate_serial` - номер сертификата из HTML
- `certificate_alias` - оставить пустым, так как в парсируемой странице нет этих данных
- `expiry_date` - из HTML
- `status` - определить по сроку действия (если истек - `needs_update`, иначе - `active`)
- Остальные поля - пустые или значения по умолчанию

**Вопрос:**
20. Не нужно автоматически устанавливать статус `needs_update` для сертификатов, срок действия которых истекает в ближайшее время.
